"""Unit tests for the fitsGBT module and it's main classes.

This test suit depends on there being the appropriate test fits data.  Please
run make_test_GBT_fits_file.py from this directory to generate this.  You will
need to point your system variables to some raw data.
"""

import unittest
import copy
import os

import scipy as sp
import numpy.ma as ma

import fitsGBT
import data_block as db
import kiyopy.custom_exceptions as ce

# This fits file generated by the script make_test_GBT_fits_file.py
testfile_gos = 'testdata/testfile_GBTfits.fits'
# This file has known properties:
bands_gos = (695, 725)
scans_gos = (17, 18)
pol_set = (-5, -7, -8, -6)
cal_set = ('T', 'F')
nband_gos = len(bands_gos)
nscan_gos = len(scans_gos)
ntime_gos = 10
npol_gos = len(pol_set)
ncal_gos = len(cal_set)
nchan_gos = npol_gos * ncal_gos
nfreq_gos = 2048




class TestWriter(unittest.TestCase) :
    """Unit tests for fits file writer.
    """

    def setUp(self) :
        self.Writer = fits.SpecWriter(feedback = 0)
        self.Reader = fits.SpecReader(testfile_gos, 0)
        Block = self.Reader.read(0, 0)
        self.Writer.add_data(Block)

    def test_add_data(self) :
        for field_name in fitsGBT.fields_and_axes.iterkeys() :
            if field_name not in ['RA', 'DEC']:
                self.assertEqual(len(self.Writer.field[field_name]),
                                 ntime_gos*npol_gos*ncal_gos)
        Block = self.Reader.read(1, 0)
        self.Writer.add_data(Block)
        for field_name in fitsGBT.fields_and_axes.iterkeys() :
            if field_name not in ['RA', 'DEC']:
                self.assertEqual(len(self.Writer.field[field_name]),
                                 2*ntime_gos*npol_gos*ncal_gos)

    def test_error_on_bad_format(self) :
        Block = self.Reader.read(1, 0)
        Block.field_formats['CRVAL1'] = '1I'
        self.assertRaises(ce.DataError, self.Writer.add_data, Block)

    def tearDown(self) :
        del self.Writer
        del self.Reader

class TestCircle(unittest.TestCase) :
    """Circle tests for the reader and writer.

    I'm sure there is a word for it, but I've dubbed a circle test when you
    read some data, do something to it, then write it and read it again.  Then
    check it element by element that it hasn't changed.
    """

    def setUp(self) :
        self.Reader = fits.SpecReader(testfile_gos, 0)
        self.Blocks = list(self.Reader.read([], []))
        # Manually add in RA and DEC fields as test data was created before
        # these were standard.
        for Data in self.Blocks:
            ntime = Data.dims[0]
            Data.set_field('RA', sp.arange(ntime, dtype=sp.float64),
                    axis_names=('time',))
            Data.set_field('DEC', sp.arange(ntime, 0, -1, dtype=sp.float64),
                    axis_names=('time',))

    def circle(self) :
        self.BlocksToWrite = copy.deepcopy(self.Blocks)
        self.Writer = fits.SpecWriter(self.BlocksToWrite, 0)
        self.Writer.write('temp.fits')
        self.newReader = fits.SpecReader('temp.fits', 0)
        self.newBlocks = self.newReader.read()

        self.assertEqual(len(self.Blocks), len(self.newBlocks))
        for ii in range(len(self.newBlocks)) :
            OldDB = self.Blocks[ii]
            NewDB = self.newBlocks[ii]
            for jj in range(4) :
                self.assertEqual(OldDB.dims[ii], NewDB.dims[ii])
            self.assertTrue(ma.allclose(OldDB.data, NewDB.data))
            for field, axis in fitsGBT.fields_and_axes.iteritems() :
                if field in OldDB.field.keys():
                    self.assertEqual(axis, OldDB.field_axes[field])
                    self.assertEqual(axis, NewDB.field_axes[field])
            for field in ['SCAN', 'OBJECT', 'TIMESTAMP',
                          'OBSERVER', 'CRPIX1', 'CDELT1'] :
                self.assertEqual(OldDB.field[field], NewDB.field[field])
            for field in ['CRVAL1', 'BANDWID', 'RESTFREQ', 'DURATION'] :
                self.assertAlmostEqual(OldDB.field[field], NewDB.field[field])
            for field in ['LST', 'ELEVATIO', 'AZIMUTH', 'RA', 'DEC',
                          'OBSFREQ', 'CRVAL2', 'CRVAL3', 'EXPOSURE'] :
                self.assertTrue(sp.allclose(OldDB.field[field], 
                                            NewDB.field[field]))
            for field in ['DATE-OBS'] :
                self.assertTrue(sp.alltrue(sp.equal(OldDB.field[field], 
                                            NewDB.field[field])))
            for field in ['CRVAL4', 'CAL'] :
                self.assertTrue(all(OldDB.field[field] == NewDB.field[field]))

    def test_basic(self) :
        self.circle()

    def test_masking(self) :
        self.Blocks[1].data[3,2,1,30] = ma.masked
        self.circle()
        self.assertTrue(sp.all(self.Blocks[1].data.mask == 
                            self.newBlocks[1].data.mask))

    def tearDown(self) :
        del self.Reader
        del self.Writer
        del self.newReader
        os.remove('temp.fits')

class TestHistory(unittest.TestCase) :
    """Tests that histories are read, added and written."""

    def setUp(self) :
        # testfile_gos has no history.
        self.Reader = fits.SpecReader(testfile_gos, 0)

    def test_reads_history(self) :
        self.Reader.hdulist[0].header.update('DB-HIST', 'First History')
        self.Reader.hdulist[0].header.update('DB-DET', 'A Detail')
        Block1 = self.Reader.read(0, 0)
        Block = self.Reader.read(0, 1)
        self.assertTrue(Block.history.has_key('000: First History'))
        self.assertEqual(Block.history['000: First History'][0], 'A Detail')
        self.assertTrue(Block.history.has_key('001: Read from file.'))
        self.assertEqual(Block.history['001: Read from file.'][0], 
                        'File name: ' + testfile_gos)

    def test_writes_history(self) :
        # Mock up a work flow history
        Block1 = self.Reader.read(0, 0)
        Block2 = self.Reader.read(0, 1)
        Block1.add_history('Processed.', ('Processing detail 1',))
        Block2.add_history('Processed.', ('Processing detail 2',))
        hist_entry = ("This is a long history entry that is much longer than "
                      "80 characters and should cause a wrapping of the fits "
                      "history key.")
        hist_detail = ("We really want to check that the pyfits "
                       "mechanisms/any supporting code that Ive written can "
                       "properly deal with this.",)
        Block1.add_history(hist_entry, hist_detail)
        Block2.add_history(hist_entry, hist_detail)
        Writer = fits.SpecWriter((Block1, Block2), 0)
        Writer.write('temp2.fits')
        newReader = fits.SpecReader('temp2.fits', 0)
        newBlock = newReader.read(0,0)
        # These two line need to come before anything likly to fail.
        del newReader
        os.remove('temp2.fits')
        # See that we have all the history we expect.
        hist = newBlock.history
        self.assertTrue(hist.has_key('000: Read from file.'))
        self.assertEqual(len(hist['000: Read from file.']), 1)
        self.assertTrue(hist.has_key('001: Processed.'))
        self.assertEqual(len(hist['001: Processed.']), 2)
        self.assertEqual(hist['001: Processed.'][0], 'Processing detail 1')
        self.assertEqual(hist['001: Processed.'][1], 'Processing detail 2')
        self.assertTrue(hist.has_key('002: ' + hist_entry))
        self.assertEqual(len(hist['002: ' + hist_entry]), 1)
        self.assertEqual(hist['002: ' + hist_entry][0], hist_detail[0])
        self.assertTrue(hist.has_key('003: Written to file.'))
        self.assertEqual(len(hist['003: Written to file.']), 1)
        self.assertEqual(hist['003: Written to file.'][0], 'File name: ' + 
                         'temp2.fits')
        self.assertTrue(hist.has_key('004: Read from file.'))


    def tearDown(self) :
        del self.Reader

        
                

if __name__ == '__main__' :
    unittest.main()

