"""Unit tests for the fitsGBT module and it's main classes.

This test suit depends on there being the appropriate test fits data.  Please
run make_test_GBT_fits_file.py from this directory to generate this.  You will
need to point your system variables to some raw data.
"""

import unittest
import copy
import os

import scipy as sp
import numpy.ma as ma

import fitsGBT
import data_block as db
import kiyopy.custom_exceptions as ce

# This fits file generated by the script make_test_GBT_fits_file.py
testfile_gos = 'testdata/testfile_GBTfits.fits'
# This file has known properties:
bands_gos = (695, 725)
scans_gos = (17, 18)
pol_set = (-5, -7, -8, -6)
cal_set = ('T', 'F')
nband_gos = len(bands_gos)
nscan_gos = len(scans_gos)
ntime_gos = 10
npol_gos = len(pol_set)
ncal_gos = len(cal_set)
nfreq_gos = 2048

# The name FileProcessor was inherited from an earlier version of this class.
# It is now not a processor but simple a Reader.
class TestReaderInit(unittest.TestCase) :
    
    def setUp(self) :
        self.FileProcessor = fits.SpecReader(testfile_gos, 0)

    def test_gets_IFs(self) :
        for ii in range(len(bands_gos)) :
            self.assertAlmostEqual(self.FileProcessor.bands_gos[ii], bands_gos[ii])

    def test_gets_scans(self) :
        for ii in range(len(scans_gos)) :
            self.assertEqual(self.FileProcessor.scans_gos[ii], scans_gos[ii])

    def tearDown(self) :
        del self.FileProcessor

class TestReaderGetIFScanInds(unittest.TestCase) :
    
    def setUp(self) : 
        self.FileProcessor = fits.SpecReader(testfile_gos, 0)
        self.IFs_all = sp.array(self.FileProcessor.fitsdata.field('CRVAL1')/1E6)
        self.IFs_all  = self.IFs_all.round(0)
        self.IFs_all  = sp.array(self.IFs_all, int)
        self.scans_all = sp.array(self.FileProcessor.fitsdata.field('SCAN'))

    def test_gets_records(self) :
        for scan_ind in range(2) :
            for IF_ind in range(2) :
                inds = self.FileProcessor.get_scan_IF_inds(scan_ind, IF_ind)
                IFs = self.IFs_all[inds]
                scans = self.scans_all[inds]
                # Verify we got all of them.
                self.assertEqual(sp.size(inds), npol_gos*ncal_gos*ntime_gos)
                # Verify they are all unique.
                self.assertEqual(len(sp.unique(inds)), npol_gos*ncal_gos*ntime_gos)
                # Check that they are all right.
                wrong_scan = sp.where(sp.not_equal(scans, scans_gos[scan_ind]))
                wrong_IF = sp.where(sp.not_equal(IFs, bands_gos[IF_ind]))
                self.assertEqual(len(wrong_scan[0]), 0)
                self.assertEqual(len(wrong_IF[0]), 0)

    def test_reforms_records(self) :
        """Test reshaping of indicies to time x pol x cal."""
        
        # Get the inds of a scan and IF and use them to get some data.
        inds = self.FileProcessor.get_scan_IF_inds(1, 1)
        LST = sp.array(self.FileProcessor.fitsdata.field('LST')[inds])
        pol = sp.array(self.FileProcessor.fitsdata.field('CRVAL4')[inds])
        cal = sp.array(self.FileProcessor.fitsdata.field('CAL')[inds])
        # Test that the indicies have the proper shape
        shape_expected = (ntime_gos, npol_gos, ncal_gos)
        self.assertEqual(shape_expected, sp.shape(inds))
        # Make sure that LST is constant of indicies 1,2.  Etc. for pol, cal.
        aLST = sp.unique(LST[0,:,:])
        self.assertEqual(len(aLST), 1)
        apol = sp.unique(pol[:,0,:])
        self.assertEqual(len(apol), 1)
        acal = sp.unique(cal[:,:,0])
        self.assertEqual(len(acal), 1)

    def test_checks_data_order(self) :
        """Puts pols out of order and check if exception is raised."""

        # Mess up the cals in one of the scans, IFs
        inds = self.FileProcessor.get_scan_IF_inds(1, 1)
        self.FileProcessor.fitsdata.field('CAL')[inds[1,1,1]] = 'T'
        self.FileProcessor.fitsdata.field('CAL')[inds[1,1,0]] = 'T'
        # See if an error is raised when we try to re-get the inds.
        self.assertRaises(ce.DataError, self.FileProcessor.get_scan_IF_inds,
                          1, 1)
        # Mess up the pols in another of the scans, IFs
        inds = self.FileProcessor.get_scan_IF_inds(0, 0)
        self.FileProcessor.fitsdata.field('CRVAL4')[inds[1,1,1]] = '-8'
        self.FileProcessor.fitsdata.field('CRVAL4')[inds[1,2,1]] = '-8'
        self.assertRaises(ce.DataError, self.FileProcessor.get_scan_IF_inds,
                          0, 0)
        # Keep times in order but make one them slightly off.
        inds = self.FileProcessor.get_scan_IF_inds(0, 1)
        self.FileProcessor.fitsdata.field('LST')[inds[4,0,0]] = \
            self.FileProcessor.fitsdata.field('LST')[inds[4,0,0]] + 0.01
        self.assertRaises(ce.DataError, self.FileProcessor.get_scan_IF_inds,
                          0, 1)


    def tearDown(self) :
        del self.FileProcessor

class TestReads(unittest.TestCase) :
    """Some basic test for some know properties of the data in the test fits
    file."""
    
    def setUp(self) :
        self.Reader = fits.SpecReader(testfile_gos, 0, 1)
        self.datashape = (ntime_gos, npol_gos, ncal_gos, nfreq_gos)
        self.DBlock = self.Reader.read(0, 0)
        self.DBlock.verify()

    def test_reads_valid_data(self) :
        for ii in range(4) :
            self.assertEqual(self.datashape[ii], self.DBlock.dims[ii])
        
    def test_feilds(self) :
        self.assertEqual(self.DBlock.field['SCAN'], scans_gos[0])
        self.assertEqual(round(self.DBlock.field['CRVAL1']/1e6), 695)
        for ii in range(npol_gos) :
            self.assertEqual(pol_set[ii], self.DBlock.field['CRVAL4'][ii])
        for ii in range(ncal_gos) :
            self.assertEqual(cal_set[ii], self.DBlock.field['CAL'][ii])
        self.assertEqual(self.DBlock.field_formats['CRVAL1'], '1D')
        self.assertEqual(self.DBlock.field_formats['CRVAL4'], '1I')
        # Multi Dimensional field read.
        self.assertEqual(self.DBlock.field['EXPOSURE'].shape, 
                         (ntime_gos, ncal_gos))
        self.assertEqual(self.DBlock.field_axes['EXPOSURE'], 
                         ('time', 'cal'))

    def tearDown(self) :
        del self.Reader
        del self.DBlock

class TestMultiRead(unittest.TestCase) :
    """Test that each scan and IF is read exactly 1 time by default."""
    
    def setUp(self) :
        self.nscan_gos = len(scans_gos)
        self.nband_gos = len(bands_gos)
        self.Reader = fits.SpecReader(testfile_gos, 0)
        
    def test_multiple_reads(self) :
        Blocks = self.Reader.read()
        self.assertEqual(len(Blocks), nscan_gos*nband_gos)
        # Lists multiplied by two because each scan shows up in 2 IFs.
        scan_list = 2*list(scans_gos)
        IF_list = 2*list(bands_gos)
        for DB in Blocks :
            DB.verify()
            the_scan = DB.field['SCAN']
            the_IF = int(round(DB.field['CRVAL1']/1e6))
            self.assertTrue(scan_list.count(the_scan))
            scan_list.remove(the_scan)
            self.assertTrue(IF_list.count(the_IF))
            IF_list.remove(the_IF)

class TestWriter(unittest.TestCase) :
    """Unit tests for fits file writer.
    """

    def setUp(self) :
        self.Writer = fits.SpecWriter(feedback = 0)
        self.Reader = fits.SpecReader(testfile_gos, 0)
        Block = self.Reader.read(0, 0)
        self.Writer.add_data(Block)

    def test_add_data(self) :
        for field_name in fitsGBT.fields_and_axes.iterkeys() :
            if field_name not in ['RA', 'DEC']:
                self.assertEqual(len(self.Writer.field[field_name]),
                                 ntime_gos*npol_gos*ncal_gos)
        Block = self.Reader.read(1, 0)
        self.Writer.add_data(Block)
        for field_name in fitsGBT.fields_and_axes.iterkeys() :
            if field_name not in ['RA', 'DEC']:
                self.assertEqual(len(self.Writer.field[field_name]),
                                 2*ntime_gos*npol_gos*ncal_gos)

    def test_error_on_bad_format(self) :
        Block = self.Reader.read(1, 0)
        Block.field_formats['CRVAL1'] = '1I'
        self.assertRaises(ce.DataError, self.Writer.add_data, Block)

    def tearDown(self) :
        del self.Writer
        del self.Reader

class TestCircle(unittest.TestCase) :
    """Circle tests for the reader and writer.

    I'm sure there is a word for it, but I've dubbed a circle test when you
    read some data, do something to it, then write it and read it again.  Then
    check it element by element that it hasn't changed.
    """

    def setUp(self) :
        self.Reader = fits.SpecReader(testfile_gos, 0)
        self.Blocks = list(self.Reader.read([], []))
        # Manually add in RA and DEC fields as test data was created before
        # these were standard.
        for Data in self.Blocks:
            ntime = Data.dims[0]
            Data.set_field('RA', sp.arange(ntime, dtype=sp.float64),
                    axis_names=('time',))
            Data.set_field('DEC', sp.arange(ntime, 0, -1, dtype=sp.float64),
                    axis_names=('time',))

    def circle(self) :
        self.BlocksToWrite = copy.deepcopy(self.Blocks)
        self.Writer = fits.SpecWriter(self.BlocksToWrite, 0)
        self.Writer.write('temp.fits')
        self.newReader = fits.SpecReader('temp.fits', 0)
        self.newBlocks = self.newReader.read()

        self.assertEqual(len(self.Blocks), len(self.newBlocks))
        for ii in range(len(self.newBlocks)) :
            OldDB = self.Blocks[ii]
            NewDB = self.newBlocks[ii]
            for jj in range(4) :
                self.assertEqual(OldDB.dims[ii], NewDB.dims[ii])
            self.assertTrue(ma.allclose(OldDB.data, NewDB.data))
            for field, axis in fitsGBT.fields_and_axes.iteritems() :
                if field in OldDB.field.keys():
                    self.assertEqual(axis, OldDB.field_axes[field])
                    self.assertEqual(axis, NewDB.field_axes[field])
            for field in ['SCAN', 'OBJECT', 'TIMESTAMP',
                          'OBSERVER', 'CRPIX1', 'CDELT1'] :
                self.assertEqual(OldDB.field[field], NewDB.field[field])
            for field in ['CRVAL1', 'BANDWID', 'RESTFREQ', 'DURATION'] :
                self.assertAlmostEqual(OldDB.field[field], NewDB.field[field])
            for field in ['LST', 'ELEVATIO', 'AZIMUTH', 'RA', 'DEC',
                          'OBSFREQ', 'CRVAL2', 'CRVAL3', 'EXPOSURE'] :
                self.assertTrue(sp.allclose(OldDB.field[field], 
                                            NewDB.field[field]))
            for field in ['DATE-OBS'] :
                self.assertTrue(sp.alltrue(sp.equal(OldDB.field[field], 
                                            NewDB.field[field])))
            for field in ['CRVAL4', 'CAL'] :
                self.assertTrue(all(OldDB.field[field] == NewDB.field[field]))

    def test_basic(self) :
        self.circle()

    def test_masking(self) :
        self.Blocks[1].data[3,2,1,30] = ma.masked
        self.circle()
        self.assertTrue(sp.all(self.Blocks[1].data.mask == 
                            self.newBlocks[1].data.mask))

    def tearDown(self) :
        del self.Reader
        del self.Writer
        del self.newReader
        os.remove('temp.fits')

class TestHistory(unittest.TestCase) :
    """Tests that histories are read, added and written."""

    def setUp(self) :
        # testfile_gos has no history.
        self.Reader = fits.SpecReader(testfile_gos, 0)

    def test_reads_history(self) :
        self.Reader.hdulist[0].header.update('DB-HIST', 'First History')
        self.Reader.hdulist[0].header.update('DB-DET', 'A Detail')
        Block1 = self.Reader.read(0, 0)
        Block = self.Reader.read(0, 1)
        self.assertTrue(Block.history.has_key('000: First History'))
        self.assertEqual(Block.history['000: First History'][0], 'A Detail')
        self.assertTrue(Block.history.has_key('001: Read from file.'))
        self.assertEqual(Block.history['001: Read from file.'][0], 
                        'File name: ' + testfile_gos)

    def test_writes_history(self) :
        # Mock up a work flow history
        Block1 = self.Reader.read(0, 0)
        Block2 = self.Reader.read(0, 1)
        Block1.add_history('Processed.', ('Processing detail 1',))
        Block2.add_history('Processed.', ('Processing detail 2',))
        hist_entry = ("This is a long history entry that is much longer than "
                      "80 characters and should cause a wrapping of the fits "
                      "history key.")
        hist_detail = ("We really want to check that the pyfits "
                       "mechanisms/any supporting code that Ive written can "
                       "properly deal with this.",)
        Block1.add_history(hist_entry, hist_detail)
        Block2.add_history(hist_entry, hist_detail)
        Writer = fits.SpecWriter((Block1, Block2), 0)
        Writer.write('temp2.fits')
        newReader = fits.SpecReader('temp2.fits', 0)
        newBlock = newReader.read(0,0)
        # These two line need to come before anything likly to fail.
        del newReader
        os.remove('temp2.fits')
        # See that we have all the history we expect.
        hist = newBlock.history
        self.assertTrue(hist.has_key('000: Read from file.'))
        self.assertEqual(len(hist['000: Read from file.']), 1)
        self.assertTrue(hist.has_key('001: Processed.'))
        self.assertEqual(len(hist['001: Processed.']), 2)
        self.assertEqual(hist['001: Processed.'][0], 'Processing detail 1')
        self.assertEqual(hist['001: Processed.'][1], 'Processing detail 2')
        self.assertTrue(hist.has_key('002: ' + hist_entry))
        self.assertEqual(len(hist['002: ' + hist_entry]), 1)
        self.assertEqual(hist['002: ' + hist_entry][0], hist_detail[0])
        self.assertTrue(hist.has_key('003: Written to file.'))
        self.assertEqual(len(hist['003: Written to file.']), 1)
        self.assertEqual(hist['003: Written to file.'][0], 'File name: ' + 
                         'temp2.fits')
        self.assertTrue(hist.has_key('004: Read from file.'))


    def tearDown(self) :
        del self.Reader

        
                

if __name__ == '__main__' :
    unittest.main()

